# 🧠 System Architecture - Employee Manager (C++)

This document describes the internal architecture and design decisions for the Employee Manager system implemented in C++. It explains the key data structures, component responsibilities, and data flow within the system.

---

## 📚 Overview

The system manages employees and companies with operations such as hiring, promoting, salary updates, and merging companies. It is designed for efficiency using:

- Global and company-level hash tables
- Rank trees for salary-based operations
- Union-Find structure for managing company mergers
- Encapsulated data models for employees and salary-based keys

---

## 🔧 Core Components

### 1. EmployeeManager

Acts as the central controller for all operations. It contains:

- `employeeHash`: HashTable for all employees (global)
- `employeesTree`: RankTree for employees with salary > 0
- `Companies`: Union-Find structure managing company groups
- `companies_arr`: Array of `ArrData` pointers, one for each company

---

## 🏗️ Data Structure Visualization

```plaintext
                    ┌────────────────────┐
                    │   EmployeeManager  │
                    └────────────────────┘
                               │
       ┌──────────────────────┼──────────────────────┐
       ▼                      ▼                      ▼
┌───────────────┐     ┌────────────────┐     ┌────────────────────┐
│ employeeHash  │     │ Companies (UF) │     │    Companies_arr   │
│ Global Hash   │     │ Union-Find DS  │     │   Array of k items │
└───────────────┘     └────────────────┘     └─────────┬──────────┘
         │                                         ┌────▼────┐
         │                                         │ ArrData │
         ▼                                         └────┬────┘
  ┌───────────────┐               ┌──────────────┐   ┌──▼────────────┐
  │ EmployeeData  │               │ employeesHash│   │ employeesTree │
  │ ID, Salary,   │◄──────────────│   (per comp) │   │  (salary>0)   │
  │ Grade         │               └──────────────┘   └───────────────┘



🧱 Class Breakdown
🔹 ArrData
Describes per-company data structure.

employees_hash_arr: HashTable<EmployeeData>

employees_tree_arr: RankTree<EKeyBySalary, IntObject>

sum_grades_arr: Total grade for all employees

employees_with_zero_salary_arr: Count of zero-salary employees

🔹 EmployeeData
employeeId

salary

grade

🔹 EKeyBySalary
Used as the key in rank trees for sorting:

salary

employeeId (secondary key)

🔁 Operation Flow Examples
➕ AddEmployee
Check if employee exists.

Insert to global hash.

Add to company hash table.

If salary > 0 → add to both global and local salary trees.

Update grade sum and salary counters.

🔄 PromoteEmployee
Locate employee from hash.

If salary > 0, update in both trees.

Update grade values accordingly.

🔀 Merge Companies
Union-Find to group companies.

Merge employee trees (sorted).

Merge hash tables and metadata.

📊 Average Grade By Salary Range
Use two boundary nodes in tree.

Traverse and calculate total grades.

Divide by range length.

⏱️ Time & Space Complexity
Time Complexity (most ops): O(log*k + log n)

Space Complexity: O(n + k) where:

n = number of employees

k = number of companies

🧹 Clean-Up
Quit() method deletes:

Union-Find structure

Global trees

All company-level trees and hashes

👨‍💻 Authors
Ahmad Khader — 209113018

Mohammed Bisher — 207723040
